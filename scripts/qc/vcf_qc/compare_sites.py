#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# The Germline Genomics of Cancer (G2C)
# Copyright (c) 2025-Present, Ryan L. Collins and the Dana-Farber Cancer Institute
# Contact: Ryan Collins <Ryan_Collins@dfci.harvard.edu>
# Distributed under the terms of the GNU GPL v2.0

"""
Compare two variant site summary .BED files
"""


import argparse
import gzip
import networkx as nx
import numpy as np
import pybedtools as pbt
from Bio import bgzf
from collections import Counter
from re import sub


def populate_nodes(hits_g, bt, prefix=''):
    """
    Add all variants present in a pbt.Bedtool (bt) as nodes in a nx.Graph (hits_g)
    """

    for vt in bt:
        vid = prefix + vt.name
        hits_g.add_node(vid, chrom=vt.chrom, pos=vt.start, end=vt.end, 
                        vc=vt.fields[4], vsc=vt.fields[5], size=vt.fields[6],
                        af=vt.fields[8])

    return hits_g


def find_exact_hits(hits_g):
    """
    Search for exact variant matches of variant ID between two pbt.BedTool 
    objects and updates a graph of hits

    This expects identical variants to have identical IDs, which will be the 
    case if the input BED files were generated by clean_site_metrics.py

    Exact matches are always treated as having distance = 0 irrespective of their AFs
    """

    n_k = Counter([sub('^a_|^b_', '', nid) for nid in hits_g.nodes()])

    match_ids = [nid for nid, k in n_k.items() if k > 1]

    for base_id in match_ids:
        v1 = 'a_' + base_id
        v2 = 'b_' + base_id
        hits_g.add_edge(v1, v2, dist=0)

    return hits_g


def node_distance(starts, ends, afs):
    """
    Compute the distance between two variants

    Distance is defined as Euclidean/linear according to:
    A. 1 - footprint jaccard index (bp overlapping / total bp spanned by both variants)
    B. normalized left breakpoint distance (distance between starts / total bp spanned by both variants)
    C. normalized right breakpoint distance (distance between ends / total bp spanned by both variants)
    D. allele frequency difference
    """

    bp_span = np.abs(np.max(ends) - np.min(starts))
    bp_ovr = np.abs(np.min(ends) - np.max(starts))
    ovr_jac = bp_ovr / bp_span

    lbp_d = (np.max(starts) - np.min(starts)) / bp_span

    rbp_d = (np.max(ends) - np.min(ends)) / bp_span

    af_d = np.max(afs) - np.min(afs)

    return np.sqrt((ovr_jac ** 2) + (lbp_d ** 2) + (rbp_d ** 2) + (af_d ** 2))


def prune_hits(hits_g):
    """
    Prune edges in a graph of overlapping variants until no node has < 2 edges
    """

    node_ids = hits_g.nodes()

    n_edges = {nid : len(hits_g.edges(nid)) for nid in node_ids}

    while max(n_edges.values()) > 1:
        import pdb; pdb.set_trace()

    return hits_g


def main():
    """
    Main block
    """
    parser = argparse.ArgumentParser(
             description=__doc__,
             formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('-a', '--sites-a', metavar='file', required=True,
                        help='First sites.bed file. Must be sorted. Required.')
    parser.add_argument('-b', '--sites-b', metavar='file', required=True,
                        help='Second sites.bed file. Must be sorted. Required.')
    parser.add_argument('-o', '--output-prefix', help='Prefix for all output files',
                        metavar='path', default='./compare_sites')
    parser.add_argument('-m', '--comparison-mode', choices='exact overlap both'.split(),
                        default='exact', help='Criteria to impose when searching ' +
                        'for overlapping variants. [default: exact matches]')
    parser.add_argument('-r', '--min-reciprocal-overlap', type=float, default=0.1,
                        metavar='float', help='Minimum reciprocal overlap to ' +
                        'permit for --comparison-mode "overlap" or "both" ' +
                        '[default: 0.1]')
    parser.add_argument('-s', '--min-overlap-var-size', type=int, default=10,
                        metavar='int', help='Minimum variant size to ' +
                        'consider for --comparison-mode "overlap" or "both" ' +
                        '[default: 10]')
    parser.add_argument('-z', '--gzip', action='store_true', help='Compress ' +
                        'output files with gzip/bgzip [default: write ' + 
                        'uncompressed .tsv/.bed]')
    args = parser.parse_args()

    # Open connections to BED files as pbt.BedTool
    a_bt = pbt.BedTool(args.sites_a)
    b_bt = pbt.BedTool(args.sites_b)

    # Record candidate overlaps as an nx.Graph
    hits = nx.Graph()
    hits = populate_nodes(hits, a_bt, prefix='a_')
    hits = populate_nodes(hits, b_bt, prefix='b_')

    # Look for exact matches, if optioned
    if args.comparison_mode in 'exact both'.split():
        hits = find_exact_hits(hits)

    # Look for matches based on overlap, if optioned
    # TODO: implement this

    # Process candidate matches to generate 1:1 mapping of hits
    hits = prune_hits(hits)

    # Write output files
    # TODO: implement this


if __name__ == '__main__':
    main()

